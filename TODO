- Value types in opIndexAssign need to allow implicit conversions too!
- BUG: AA!(immutable char[4],int) can't be instantiated.
- Introduce toHash methods for all native types (via UFCS). This will solve the
  stupid purity/nothrow idiocies with the current TypeInfo.getHash.
   * Note: beware of custom getHash() methods in the pre-built TypeInfo's;
     the toHash counterparts should return identical values.
- Implement compile-time instantiation of AA's:
   - Use CTFE to build the AA at compile-time, then transform it via mixins
     into static structs.
- Investigate how to make signature constraints work so that compiler magic
  with wstring/dstring literals will still work properly.
- Key should be implicitly immutable?
   + Support mutable key types for now.
+ IMPORTANT: .get, .opIndex, and .opBinaryRight!"in" need to accept key types
  that implicit convert to Key, not just Key itself.
   + Also, .opIndexAssign needs to be clever enough to NOT copy the input key
     unless it needs to create a new entry.
   + For this, we need to ensure that the input key type is: (1) comparable
     to Key, and (2) implicitly convertible to Key.
      + Andrei's request, however, goes even further: we should invoke .idup on
        the input key if it's not immutable but has an .idup method that
        returns immutable. This way, we can lookup X[string] with char[], for
        example, or even add char[] keys to the hash and have it automatically
        convert to immutable.
+ Implement .remove
   P Possible to make it safe inside opApply? (Probably not.)
+ Implement .toHash
+ Implement AA literals:
   + We may not have compiler support for syntactic sugar ATM, but that
     shouldn't stop us from implementing an interfacing function that can
     construct AA's that the compiler can hook into in the future.
